#include <iostream>
#include <thread>

#include <websocketswrapper.h>

#ifndef ASIO_STANDALONE
#define ASIO_STANDALONE
#endif

#include <asio.hpp>
#include <websocketpp/config/asio_client.hpp>
#include <websocketpp/client.hpp>

namespace wswrap {
    typedef websocketpp::lib::shared_ptr<websocketpp::lib::asio::ssl::context> context_ptr;
    typedef websocketpp::config::asio_client::message_type::ptr message_ptr;
    typedef websocketpp::client<websocketpp::config::asio_tls_client> client;
}

namespace internal {
    class bridge : public std::enable_shared_from_this<bridge> {
        public:
            typedef asio::ip::tcp::socket socket_type;
            typedef std::shared_ptr<bridge> ptr_type;

            bridge(socket_type socket, wswrap::client::connection_ptr wsconnection)
                : socket_(std::move(socket)), wsconn_(std::move(wsconnection)
            ) {
                // Set up reads from the socket and the websocket
                socket_.async_read_some(
                    asio::buffer(socket_data_, max_data_length),
                    std::bind(
                        &bridge::handle_socket_read,
                        shared_from_this(),
                        std::placeholders::_1,
                        std::placeholders::_2
                    )
                );

                wsconn_->set_message_handler(
                    std::bind(
                        &bridge::handle_ws_read,
                        shared_from_this(),
                        std::placeholders::_1,
                        std::placeholders::_2
                    )
                );
            }

        private:

            // This handler is called over and over by websocketpp, we do not
            // need to retrigger it
            void handle_ws_read(websocketpp::connection_hdl hdl, wswrap::message_ptr msg) {
                // Append the data to the queue of data to be sent, this copies
                // the data because the lifetime of the payload is determined
                // by websocketpp and we don't control it
                ws_data_.emplace(msg->get_payload());

                // Trigger an async write on the socket as necessary
                maybe_write_to_socket();
            }

            // Unfortunately we can't just keep calling async_write, so we end
            // up having to manually deal with this mess by using a queue and a
            // flag to know when we are done writing.
            void maybe_write_to_socket() {
                if (write_clear && !ws_data_.empty()) {
                    write_clear = false;

                    async_write(socket_,
                        asio::buffer(ws_data_.front(), ws_data_.front().length()),
                        std::bind(&bridge::handle_socket_write,
                            shared_from_this(),
                            std::placeholders::_1));
                }
            }

            // This handler is called once after being triggered, so we need to
            // make sure to trigger it again
            void handle_socket_read(
                const asio::error_code& error,
                const size_t& bytes_transferred
            ) {
                if (!error) {
                    // We received some data, send it to the websocket
                    wsconn_->send(&socket_data_, bytes_transferred);

                    // Reset trigger so we get called again
                    socket_.async_read_some(
                        asio::buffer(socket_data_, max_data_length),
                        std::bind(
                            &bridge::handle_socket_read,
                            shared_from_this(),
                            std::placeholders::_1,
                            std::placeholders::_2
                        )
                    );

                } else {
                    close();
                }
            }

            // This is triggered when we complete the write that came in from
            void handle_socket_write(const asio::error_code& error) {
                if (!error) {
                    // Remove the front-most entry
                    ws_data_.pop();

                    // Clear the flag
                    write_clear = true;

                    // Do we have more to send? Do it.
                    maybe_write_to_socket();
                } else {
                    close();
                }
            }

            void close() {
                // TODO(bert.regeer): Do proper cleanup of the socket/websocket
                // connection
            }

            socket_type socket_;
            wswrap::client::connection_ptr wsconn_;

            static const int max_data_length = 8192; //8KB
            std::array<unsigned char, max_data_length> socket_data_;
            std::queue<std::string> ws_data_;
            bool write_clear;
            std::mutex mutex_;
    };

    class acceptor {
        public:
            acceptor(
                asio::io_service& io_service,
                const asio::ip::address_v4& local_host,
                unsigned short local_port,
                std::function<void(asio::ip::tcp::socket)> sockethandler
            ) :
                io_service_(io_service),
                socket_(io_service_),
                localhost_address(local_host),
                acceptor_(
                    io_service_,
                    asio::ip::tcp::endpoint(
                        localhost_address,
                        local_port
                    )
                ),
                sockethandler_(sockethandler)
            {}

            asio::ip::tcp::endpoint local_endpoint() {
                return acceptor_.local_endpoint();
            }

            bool accept_connections()
            {
                try
                {
                    acceptor_.async_accept(socket_,
                        std::bind(&acceptor::handle_accept,
                            this,
                            std::placeholders::_1));
                }
                catch (std::exception& e)
                {
                    std::cerr << "Unable to start accepting connections: " << e.what() << std::endl;
                    return false;
                }

                return true;
            }

        private:

            void handle_accept(const asio::error_code& error)
            {
                if (!error)
                {
                    sockethandler_(std::move(socket_));

                    if (!accept_connections())
                    {
                        std::cerr << "Accepted connection, and now can't accept more!" << std::endl;
                    }
                }
                else
                {
                    std::cerr << "Error: " << error.message() << std::endl;
                }
            }

            asio::io_service& io_service_;
            asio::ip::tcp::socket socket_;
            asio::ip::address_v4 localhost_address;
            asio::ip::tcp::acceptor acceptor_;
            std::function<void(asio::ip::tcp::socket)> sockethandler_;
    };
}

WebsocketsWrapper::WebsocketsWrapper(std::string c2_uri) :
    pimpl_(std::make_unique<WebsocketsWrapper::impl>(c2_uri))
{}

WebsocketsWrapper::~WebsocketsWrapper() {

}

class WebsocketsWrapper::impl {
    public:
        impl(std::string& c2_uri) :
            uri_(c2_uri),
            aio_work_(std::make_shared<asio::io_service::work>(aio_context_)),
            io_runner_(
                    std::thread(
                        [&] {
                            // Start up the asio context in a thread, forever
                            aio_context_.run();
                        }
                    )
            ),
            acceptor_(
                aio_context_,
                asio::ip::address_v4::loopback(),
                0,
                [&] (asio::ip::tcp::socket socket) {
                    // TODO(bert.regeer): create the new websocket connection
                    // and use it here...
                    auto bridge = std::make_shared<internal::bridge>(std::move(socket), nullptr);
                    std::cerr << "Accepted a connection... but we ain't got nothing forwarding" << std::endl;
                }
            )
        {
            acceptor_.accept_connections();

            // Get the local information and store it upon creation
            auto local_info = acceptor_.local_endpoint();
            local_ip_ = local_info.address().to_string();
            local_port_ = local_info.port();
        }

        ~impl() {
            // Do all the necessary teardown, in the right order

            // Let asio know it's time for a nap
            aio_work_.reset();

            // Now we wait on the thread to finish what its doing
            io_runner_.join();
        }

    private:
        wswrap::client wsclient_;

        std::string uri_;
        asio::io_context aio_context_;
        std::shared_ptr<asio::io_service::work> aio_work_;
        std::thread io_runner_;
        internal::acceptor acceptor_;

    public:
        std::string local_ip_;
        unsigned int local_port_;
};

std::string& WebsocketsWrapper::local_ip() {
    return pimpl_->local_ip_;
}

unsigned int WebsocketsWrapper::local_port() {
    return pimpl_->local_port_;
}
