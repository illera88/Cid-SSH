#include <iostream>
#include <stdexcept>
#include <thread>

#include <websocketswrapper.h>

#ifndef ASIO_STANDALONE
#define ASIO_STANDALONE
#endif

#include <asio.hpp>
#include <websocketpp/config/asio_client.hpp>
#include <websocketpp/client.hpp>

namespace wswrap {
    typedef websocketpp::lib::shared_ptr<websocketpp::lib::asio::ssl::context> context_ptr;
    typedef websocketpp::config::asio_client::message_type::ptr message_ptr;
    typedef websocketpp::client<websocketpp::config::asio_tls_client> client;

    class websocket {
        public:
            websocket(asio::io_service& io_service, std::string uri) :
            io_service_(io_service), uri_(uri) {
                try {
                    // Set logging to be pretty verbose (everything except message payloads)
                    wsclient_.set_access_channels(websocketpp::log::alevel::all);
                    wsclient_.clear_access_channels(websocketpp::log::alevel::frame_payload);
                    wsclient_.set_error_channels(websocketpp::log::elevel::all);
                    wsclient_.set_user_agent("test11111111"); // ToDo: Set to something unique that the server will verify to prevent outsiders poking with our ssh server

                    // Initialize ASIO
                    wsclient_.init_asio(&io_service_);
                    wsclient_.set_tls_init_handler(std::bind(&websocket::on_tls_init, this, std::placeholders::_1));
                }
                catch (websocketpp::exception const& e) {
                    std::cout << e.what() << std::endl;
                }

            }

            // Caller is responsible for this connection
            client::connection_ptr new_connection() {
                websocketpp::lib::error_code ec;
                auto conn = wsclient_.get_connection(uri_, ec);

                if (ec) {
                    std::cerr << "Unable to create new websocket connection: " << ec.message() << std::endl;
                    throw std::runtime_error(std::string("Unable to create new websocket connection"));
                }

                wsclient_.connect(conn);

                return conn;
            };

        private:
            asio::io_service& io_service_;
            std::string uri_;
            wswrap::client wsclient_;

            context_ptr on_tls_init(websocketpp::connection_hdl) {
                try {
                    context_ptr ctx = websocketpp::lib::make_shared<asio::ssl::context>(asio::ssl::context::method::tlsv12_client);
                    ctx->set_options(
                        asio::ssl::context::no_sslv2 |
                        asio::ssl::context::no_sslv3 |
                        asio::ssl::context::no_tlsv1 |
                        asio::ssl::context::no_tlsv1_1 |
                        asio::ssl::context::single_dh_use);
                    // Dangerous
                    ctx->set_verify_mode(asio::ssl::verify_none);
                    return ctx;
                } catch (std::exception &e) {
                    std::cerr << "Error setting up the SSL context: " << e.what() << std::endl;
                    throw;
                }
            }
    };
}

namespace internal {
    class bridge : public std::enable_shared_from_this<bridge> {
            // Private constructor, use create()
            bridge(asio::ip::tcp::socket socket, wswrap::client::connection_ptr wsconnection)
                : socket_(std::move(socket)), wsconn_(std::move(wsconnection)
            ) {
                if (wsconn_ == nullptr) {
                    throw std::invalid_argument("No websocket connection provided.");
                }
            }

        public:
            // Ah, C++ templating can be such a joy
            template<typename ... T>
            static std::shared_ptr<bridge> create(T&& ... all) {
                // Can't use make_shared here because of visibility rules and
                // all that fun jazz...
                auto ptr = std::shared_ptr<bridge>(new bridge(std::forward<T>(all)...));
                ptr->start();
                return ptr;
            }

        private:

            void start() {
                // Set an open handler for the websocket connection
                wsconn_->set_open_handler(
                    std::bind(
                        &bridge::handle_ws_open,
                        shared_from_this(),
                        std::placeholders::_1
                    )
                );

                // Set a close handler for the websocket connection
                wsconn_->set_close_handler(
                    std::bind(
                        &bridge::handle_ws_close,
                        shared_from_this(),
                        std::placeholders::_1
                    )
                );

                // Set a message handler for the websocket connection
                wsconn_->set_message_handler(
                    std::bind(
                        &bridge::handle_ws_read,
                        shared_from_this(),
                        std::placeholders::_1,
                        std::placeholders::_2
                    )
                );
            }

            // This handler is called when the websocket handler is open, and
            // we can start sending data into it
            void handle_ws_open(websocketpp::connection_hdl hdl) {
                // Start reading from the socket to forward it on
                socket_.async_read_some(
                    asio::buffer(socket_data_, max_data_length),
                    std::bind(
                        &bridge::handle_socket_read,
                        shared_from_this(),
                        std::placeholders::_1,
                        std::placeholders::_2
                    )
                );
            }

            // This handle will be called when the websocket connection is
            // closed
            void handle_ws_close(websocketpp::connection_hdl hdl) {
                // Close out our other socket if the websocket goes away
                close();
            }

            // This handler is called over and over by websocketpp, we do not
            // need to retrigger it
            void handle_ws_read(websocketpp::connection_hdl hdl, wswrap::message_ptr msg) {
                // Append the data to the queue of data to be sent, this copies
                // the data because the lifetime of the payload is determined
                // by websocketpp and we don't control it
                ws_data_.emplace(msg->get_payload());

                // Trigger an async write on the socket as necessary
                maybe_write_to_socket();
            }

            // Unfortunately we can't just keep calling async_write, so we end
            // up having to manually deal with this mess by using a queue and a
            // flag to know when we are done writing.
            void maybe_write_to_socket() {
                if (write_clear && !ws_data_.empty()) {
                    write_clear = false;

                    async_write(socket_,
                        asio::buffer(ws_data_.front(), ws_data_.front().length()),
                        std::bind(&bridge::handle_socket_write,
                            shared_from_this(),
                            std::placeholders::_1));
                }
            }

            // This handler is called once after being triggered, so we need to
            // make sure to trigger it again
            void handle_socket_read(
                const asio::error_code& error,
                const size_t& bytes_transferred
            ) {
                if (!error) {
                    // We received some data, send it to the websocket
                    wsconn_->send(&socket_data_, bytes_transferred);

                    // Reset trigger so we get called again
                    socket_.async_read_some(
                        asio::buffer(socket_data_, max_data_length),
                        std::bind(
                            &bridge::handle_socket_read,
                            shared_from_this(),
                            std::placeholders::_1,
                            std::placeholders::_2
                        )
                    );

                } else {
                    close();
                }
            }

            // This is triggered when we complete the write that came in from
            // the websocket
            void handle_socket_write(const asio::error_code& error) {
                if (!error) {
                    // Remove the front-most entry
                    ws_data_.pop();

                    // Clear the flag
                    write_clear = true;

                    // Do we have more to send? Do it.
                    maybe_write_to_socket();
                } else {
                    close();
                }
            }

            void close() {
                std::cerr << "Closing the sockets down" << std::endl;
                if (socket_.is_open())
                {
                    socket_.close();
                }

                auto state = wsconn_->get_state();
                if (!(
                     state == websocketpp::session::state::closed ||
                     state == websocketpp::session::state::closing)
                ) {
                    wsconn_->close(websocketpp::close::status::going_away, "socket shutdown");
                }
            }

            asio::ip::tcp::socket socket_;
            wswrap::client::connection_ptr wsconn_;

            static const int max_data_length = 8192; //8KB
            std::array<unsigned char, max_data_length> socket_data_;
            std::queue<std::string> ws_data_;
            bool write_clear;
            std::mutex mutex_;
    };

    class acceptor {
        public:
            acceptor(
                asio::io_service& io_service,
                const asio::ip::address_v4& local_host,
                unsigned short local_port,
                std::function<void(asio::ip::tcp::socket)> sockethandler
            ) :
                io_service_(io_service),
                socket_(io_service_),
                localhost_address(local_host),
                acceptor_(
                    io_service_,
                    asio::ip::tcp::endpoint(
                        localhost_address,
                        local_port
                    )
                ),
                sockethandler_(sockethandler)
            {}

            asio::ip::tcp::endpoint local_endpoint() {
                return acceptor_.local_endpoint();
            }

            bool accept_connections()
            {
                try
                {
                    acceptor_.async_accept(socket_,
                        std::bind(&acceptor::handle_accept,
                            this,
                            std::placeholders::_1));
                }
                catch (std::exception& e)
                {
                    std::cerr << "Unable to start accepting connections: " << e.what() << std::endl;
                    return false;
                }

                return true;
            }

        private:

            void handle_accept(const asio::error_code& error)
            {
                if (!error)
                {
                    sockethandler_(std::move(socket_));

                    if (!accept_connections())
                    {
                        std::cerr << "Accepted connection, and now can't accept more!" << std::endl;
                    }
                }
                else
                {
                    std::cerr << "Error: " << error.message() << std::endl;
                }
            }

            asio::io_service& io_service_;
            asio::ip::tcp::socket socket_;
            asio::ip::address_v4 localhost_address;
            asio::ip::tcp::acceptor acceptor_;
            std::function<void(asio::ip::tcp::socket)> sockethandler_;
    };
}

WebsocketsWrapper::WebsocketsWrapper(std::string c2_uri) :
    pimpl_(std::make_unique<WebsocketsWrapper::impl>(c2_uri))
{}

WebsocketsWrapper::~WebsocketsWrapper() {

}

class WebsocketsWrapper::impl {
    public:
        impl(std::string& c2_uri) :
            uri_(c2_uri),
            aio_work_(std::make_shared<asio::io_service::work>(aio_context_)),
            io_runner_(
                    std::thread(
                        [&] {
                            // Start up the asio context in a thread, forever
                            aio_context_.run();
                        }
                    )
            ),
            acceptor_(
                aio_context_,
                asio::ip::address_v4::loopback(),
                0,
                [&] (asio::ip::tcp::socket socket) {
                    auto websocket_connection = websocket_.new_connection();
                    auto bridge = internal::bridge::create(std::move(socket), std::move(websocket_connection));
                }
            ),
            websocket_(aio_context_, uri_)
        {
            acceptor_.accept_connections();

            // Get the local information and store it upon creation
            auto local_info = acceptor_.local_endpoint();
            local_ip_ = local_info.address().to_string();
            local_port_ = local_info.port();
        }

        ~impl() {
            // Let asio know it's time for a nap
            aio_work_.reset();

            // Now we wait on the thread to finish what its doing
            io_runner_.join();
        }

    private:
        std::string uri_;
        asio::io_context aio_context_;
        std::shared_ptr<asio::io_service::work> aio_work_;
        std::thread io_runner_;
        internal::acceptor acceptor_;
        wswrap::websocket websocket_;

    public:
        std::string local_ip_;
        unsigned int local_port_;
};

std::string& WebsocketsWrapper::local_ip() {
    return pimpl_->local_ip_;
}

unsigned int WebsocketsWrapper::local_port() {
    return pimpl_->local_port_;
}
