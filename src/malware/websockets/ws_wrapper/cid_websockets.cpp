
#include "cid_websockets.h"


//#include "asio.hpp"


using websocketpp::lib::placeholders::_1;
using websocketpp::lib::placeholders::_2;
using websocketpp::lib::bind;

std::mutex WebsocketsWrapper::mtx;
std::vector<unsigned char> WebsocketsWrapper::buffer;

WebsocketsWrapper::WebsocketsWrapper(const char* C2_host, unsigned short C2_port)
{

    this->uri = "wss://" + std::string(C2_host) + ":" + std::to_string(C2_port);
    try {
        // Set logging to be pretty verbose (everything except message payloads)
        ws_client.set_access_channels(websocketpp::log::alevel::all);
        ws_client.clear_access_channels(websocketpp::log::alevel::frame_payload);
        ws_client.set_error_channels(websocketpp::log::elevel::all);
        ws_client.set_socket_init_handler(bind(&WebsocketsWrapper::conn_socket_handler, this, ::_1, ::_2));
        ws_client.set_user_agent("test11111111");
        
        // Initialize ASIO
        ws_client.init_asio();

        // Register our message handler
        //ws_client.set_message_handler(bind(&WebsocketsWrapper::on_message, shared_from_this(), &ws_client, ::_1, ::_2));
        ws_client.set_message_handler(bind(&WebsocketsWrapper::on_message, this, &ws_client, ::_1, ::_2));
        ws_client.set_tls_init_handler(bind(&on_tls_init, ::_1));

        websocketpp::lib::error_code ec;
        con = ws_client.get_connection(uri, ec);       

        if (ec) {
            std::cout << "could not create connection because: " << ec.message() << std::endl;
            return;
        }

        // Note that connect here only requests a connection. No network messages are
        // exchanged until the event loop starts running in the next line.
        con = ws_client.connect(con);

        


 //       std::shared_ptr<asio::thread> m_logThread(new asio::thread(&WebsocketsWrapper::run));
        // ToDo: Calling like this works 
        //ws_client.run();

        // Start the ASIO io_service run loop in a new thread
        // this will cause a single connection to be made to the server. c.run()
        // will exit when this connection is closed.
        //std::thread run_thread([&] { ws_client.run(); });


        //websocketpp::lib::thread cthread(websocketpp::lib::bind(&run, &ws_client));
        //cthread.detach();
    }
    catch (websocketpp::exception const& e) {
        std::cout << e.what() << std::endl;
    }

   // WebsocketsWrapper::connected = true;
}


void WebsocketsWrapper::conn_socket_handler(websocketpp::connection_hdl hdl, websocketpp::lib::asio::ssl::stream<websocketpp::lib::asio::ip::tcp::socket>& thing) {
    socket = &thing;
}


void WebsocketsWrapper::run()
{
    if (io_thread) {
        ws_client.stop();
        io_thread->join();
    }

    io_thread = std::make_shared<std::thread>(std::thread(&client::run, &ws_client));
}

int WebsocketsWrapper::recv_cb(socket_t socket, void* userdata, char* buffer, int size) {
    WebsocketsWrapper* ws_client = (WebsocketsWrapper*)userdata;
    websocketpp::lib::error_code ec;
    size_t read_size = -1;

    read_size = ws_client->con->get_socket().read_some(asio::buffer(buffer, size), ec);

    /*asio::ip::tcp::socket ws_socket(ws_client->con->get_raw_socket().get_io_context());
    read_size = ws_socket.read_some(asio::buffer(buffer, size), ec);*/

    if (ec) {
        // ToDo: set the proper error code 
#ifdef _WIN32
        WSASetLastError(WSAEACCES); // https://docs.microsoft.com/en-us/windows/win32/winsock/windows-sockets-error-codes-2
#else
        errno = ENOENT;
#endif // _WIN32

        std::cout << "Echo failed because: " << ec.message() << std::endl;

        return -1;
    }
    

    return read_size;
}

int WebsocketsWrapper::send_cb(socket_t socket, void* userdata, const char* buffer, int size) {
    WebsocketsWrapper* ws_client = (WebsocketsWrapper*)userdata;
    websocketpp::lib::error_code ec;
    size_t sent_size = -1;

    /* auto a = ws_client->con;
    auto y =asio::ip::tcp::socket(ws_client->con->get_raw_socket().get_io_service());
    sent_size = y.write_some(asio::buffer(buffer, size), ec);*/

    //sent_size = ws_client->socket->write_some(asio::buffer(buffer, size), ec);

    sent_size = ws_client->con->get_socket().write_some(asio::buffer(buffer, size), ec);

   // ws_client->ws_client.send(ws_client->con->get_handle(), buffer, size, websocketpp::frame::opcode::binary, ec);

    //auto perro = WebsocketsWrapper::con->get_raw_socket();

    //asio::ip::tcp::socket ws_socket(WebsocketsWrapper::con->get_raw_socket().get_io_context());
    //WebsocketsWrapper::con->send()

    //sent_size = ws_socket.write_some(asio::buffer(buffer, size), ec);

    //WebsocketsWrapper::con->send(con->get_handle(), std::string(buffer, size), websocketpp::frame::opcode::binary, ec);
    //
//    // ToDo: check the different operation codes websocketpp::frame::opcode::???
//    //ws_client->c.send(ws_client->con->get_handle(),std::string(buffer, size), websocketpp::frame::opcode::binary, ec);
//
    if (ec) {
        // ToDo: set the proper error code 
#ifdef _WIN32
        WSASetLastError(WSAEACCES); // https://docs.microsoft.com/en-us/windows/win32/winsock/windows-sockets-error-codes-2
#else
        errno = ENOENT;
#endif // _WIN32

        std::cout << "Echo failed because: " << ec.message() << std::endl;
        return -1;
    }

//    //int w = send(socket, buffer, size, 0);
    return sent_size;
}

void WebsocketsWrapper::close_cb(socket_t socket, void* userdata) {
    // Should close the ws connection
}

WebsocketsWrapper::context_ptr WebsocketsWrapper::on_tls_init(websocketpp::connection_hdl)
{
    context_ptr ctx = websocketpp::lib::make_shared<asio::ssl::context>(asio::ssl::context::sslv23);
    ctx->set_verify_mode(asio::ssl::verify_none);
    return ctx;
}


void WebsocketsWrapper::on_message(client* c, websocketpp::connection_hdl hdl, message_ptr msg)
{
    auto data = msg->get_payload();
    //msg->get_raw_payload()

    /*WebsocketsWrapper::mtx.lock();
    std::copy(data.c_str(), data.c_str() + data.size(), std::back_inserter(WebsocketsWrapper::buffer));
    WebsocketsWrapper::mtx.unlock();*/
}
