#pragma once
#ifndef ASIO_STANDALONE
#define ASIO_STANDALONE
#endif
#include <asio.hpp>

#include <websocketpp/config/asio_client.hpp>
#include <websocketpp/client.hpp>

#include "../ws_wrapper/cid_websockets.h"

typedef websocketpp::config::asio_client::message_type::ptr message_ptr;

//#include <websocketpp/server.hpp>

namespace tcp_proxy
{
    class bridge : public std::enable_shared_from_this<bridge>
    {
    public:

        typedef asio::ip::tcp::socket socket_type;
        typedef std::shared_ptr<bridge> ptr_type;

        bridge(asio::io_service& ios, const WebsocketsWrapper* ws_client)
            : downstream_socket_(ios), ws_client_(ws_client)
        {}

        socket_type& downstream_socket()
        {
            // Client socket
            return downstream_socket_;
        }

        void start()
        {
            std::cerr << "Attempting to start the bridge" << std::endl;

            // Setup async read from client (downstream)
            downstream_socket_.async_read_some(
                asio::buffer(downstream_data_, max_data_length),
                std::bind(&bridge::handle_downstream_read,
                    shared_from_this(),
                    std::placeholders::_1,
                    std::placeholders::_2));

            // Setup the callback from the WebsocketWrapper
            ws_client_->con->set_message_handler(std::bind(&bridge::handle_upstream_read, shared_from_this(), std::placeholders::_1, std::placeholders::_2));
        }   

    private:

        /*
           Section A: Remote Server --> Proxy --> Client
           Process data recieved from remote sever then send to client.
        */

        // Read from remote server complete, now send data to client
        void handle_upstream_read(websocketpp::connection_hdl hdl, message_ptr msg)
        {
            auto msg_data = msg->get_payload();

            async_write(downstream_socket_,
                asio::buffer(msg_data, msg_data.length()),
                std::bind(&bridge::handle_downstream_write,
                    shared_from_this(),
                    std::placeholders::_1));
        }

        // Write to client complete, Async read from remote server
        void handle_downstream_write(const asio::error_code& error)
        {
            if (error)
                close();
        }
        // *** End Of Section A ***


        /*
           Section B: Client --> Proxy --> Remove Server
           Process data recieved from client then write to remove server.
        */

        // Read from client complete, now send data to remote server
        void handle_downstream_read(const asio::error_code& error,
            const size_t& bytes_transferred)
        {
            if (!error)
            {
                ws_client_->con->send(downstream_data_, bytes_transferred);
            }
            else
                close();
        }

        // Write to remote server complete, Async read from client
        void handle_upstream_write(const asio::error_code& error)
        {
            if (!error)
            {
                downstream_socket_.async_read_some(
                    asio::buffer(downstream_data_, max_data_length),
                    std::bind(&bridge::handle_downstream_read,
                        shared_from_this(),
                        std::placeholders::_1,
                        std::placeholders::_2));
            }
            else
                close();
        }
        // *** End Of Section B ***

        void close();

        socket_type downstream_socket_;
        const WebsocketsWrapper* ws_client_;

        enum { max_data_length = 8192 }; //8KB
        unsigned char downstream_data_[max_data_length] = { 0 };

        std::mutex mutex_;

    public:

        class acceptor
        {
        public:

            acceptor(asio::io_service& io_service,
                const std::string& local_host, unsigned short local_port,
                const WebsocketsWrapper* ws_client)
                : io_service_(io_service),
                localhost_address(asio::ip::address_v4::from_string(local_host)),
                acceptor_(io_service_, asio::ip::tcp::endpoint(localhost_address, local_port)),
                ws_client_(ws_client)
            {}

            bool accept_connections()
            {
                try
                {
                    session_ = std::shared_ptr<bridge>(new bridge(io_service_, ws_client_));

                    acceptor_.async_accept(session_->downstream_socket(),
                        std::bind(&acceptor::handle_accept,
                            this,
                            std::placeholders::_1));
                }
                catch (std::exception& e)
                {
                    std::cerr << "acceptor exception: " << e.what() << std::endl;
                    return false;
                }

                return true;
            }

        private:

            void handle_accept(const asio::error_code& error)
            {
                if (!error)
                {
                    session_->start();

                    if (!accept_connections())
                    {
                        std::cerr << "Failure during call to accept." << std::endl;
                    }
                }
                else
                {
                    std::cerr << "Error: " << error.message() << std::endl;
                    auto a = error.message();
                }
            }

            asio::io_service& io_service_;
            asio::ip::address_v4 localhost_address;
            asio::ip::tcp::acceptor acceptor_;
            ptr_type session_;
            const WebsocketsWrapper* ws_client_;
        };

    };
}


class TCP_proxy
{
public:
    TCP_proxy(WebsocketsWrapper* ws_client, std::shared_ptr<asio::io_service> io);
    int start_proxy_server();

private:
    std::shared_ptr<asio::io_service> io;
    std::string forward_host;
    unsigned short forward_port;
    unsigned short listening_proxy_port;
    WebsocketsWrapper* ws_client_ptr;
    std::shared_ptr<std::thread> proxy_server_thread;
    std::shared_ptr<tcp_proxy::bridge::acceptor> acceptor;

    int stop_proxy_server();

};

