/*
 * Copyright (c) 2015, Peter Thorson. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the WebSocket++ Project nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

 /**
  * NOTES
  *
  * This example uses a number of standard classes through the websocketpp::lib
  * namespace. This is to allow easy switching between Boost, the C++11 STL, and 
  * the standalone Asio library. Your program need not use these namespaces if
  * you do not need this sort of flexibility.
  */

#define ASIO_STANDALONE
#define _WEBSOCKETPP_CPP11_INTERNAL_

#include <websocketpp/config/asio.hpp>

#include <websocketpp/server.hpp>

#include <iostream>
#include <map>

typedef websocketpp::server<websocketpp::config::asio_tls> server;

using websocketpp::lib::placeholders::_1;
using websocketpp::lib::placeholders::_2;
using websocketpp::lib::bind;

class ws_proxy : public std::enable_shared_from_this<ws_proxy>
{
    // pull out the type of messages sent by our config
    typedef websocketpp::config::asio::message_type::ptr message_ptr;
    typedef websocketpp::lib::shared_ptr<websocketpp::lib::asio::ssl::context> context_ptr;

    // See https://wiki.mozilla.org/Security/Server_Side_TLS for more details about
    // the TLS modes. The code below demonstrates how to implement both the modern
    enum tls_mode {
        MOZILLA_INTERMEDIATE = 1,
        MOZILLA_MODERN = 2
    };
public:
    ws_proxy();
    ~ws_proxy();
    bool is_SSH_server_up();
    void run();
    

private:

    server ws_server;
    std::map<void*, std::shared_ptr<asio::ip::tcp::socket>> active_connections;

    void on_message(server* s, websocketpp::connection_hdl hdl, message_ptr msg);
    void on_http(server* s, websocketpp::connection_hdl hdl);
    ws_proxy::context_ptr on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl);
    asio::error_code connect_SSH_server(asio::ip::tcp::socket* ssh_socket);
    void read_SSH(asio::ip::tcp::socket* ssh_socket, server* s);
    void on_open(server* s, websocketpp::connection_hdl hdl);
    void on_close(server* s, websocketpp::connection_hdl hdl);

   
};


void ws_proxy::run() {
    // Start the server accept loop
    ws_server.start_accept();

    // Start the ASIO io_service run loop
    ws_server.run();
}

bool ws_proxy::is_SSH_server_up(){
    // First let check that SSH server is up
    asio::io_service io_service;
    asio::error_code err;
    asio::ip::tcp::socket socket(io_service);
    socket.connect(asio::ip::tcp::endpoint(asio::ip::address::from_string("127.0.0.1"), 22), err);

    if (err) {
        std::cout << "Error connecting to SSH on localhost. " << err.message() << "\n";
        return false;
    }
    socket.close();
    return true;
}

ws_proxy::ws_proxy()
{
    // Initialize ASIO
    ws_server.init_asio();

    // Register our message handler
    ws_server.set_user_agent("test");
    ws_server.set_message_handler(bind(&ws_proxy::on_message, shared_from_this(), &ws_server, ::_1, ::_2));
    ws_server.set_http_handler(bind(&ws_proxy::on_http, shared_from_this(), &ws_server, ::_1));
    ws_server.set_tls_init_handler(bind(&ws_proxy::on_tls_init, shared_from_this(), MOZILLA_INTERMEDIATE, ::_1));
    ws_server.set_close_handler(bind(&ws_proxy::on_close, shared_from_this(), &ws_server, ::_1));
    ws_server.set_open_handler(bind(&ws_proxy::on_open, shared_from_this(), &ws_server, ::_1));


    // Listen on port 9002
    ws_server.listen(4443);

    
}

ws_proxy::~ws_proxy()
{
}


void ws_proxy::on_message(server* s, websocketpp::connection_hdl hdl, message_ptr msg) {
    std::cout << "on_message called with hdl: " << hdl.lock().get()
              << " and message: " << msg->get_payload()
              << std::endl;

    asio::error_code error;

    void* shr_ptr_hdl = hdl.lock().get();


    server::connection_ptr con = s->get_con_from_hdl(hdl);
    con->get_socket();

    if (active_connections.count(shr_ptr_hdl) < 1) {
        // this should not happen

        //print error
        return;
    }

    asio::write(*active_connections[shr_ptr_hdl], asio::buffer(msg->get_payload()), error);

    if (error) {
        std::cout << "send failed: " << error.message() << std::endl;
    }   
}

/*Can put any fake site you want*/
void ws_proxy::on_http(server* s, websocketpp::connection_hdl hdl) {
    server::connection_ptr con = s->get_con_from_hdl(hdl);
    
    //con->set_body("Hello World!");
    //con->set_status(websocketpp::http::status_code::ok);
    con->set_status(websocketpp::http::status_code::im_a_teapot);
}

std::string get_password() {
    return "test";
}



ws_proxy::context_ptr ws_proxy::on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {
    namespace asio = websocketpp::lib::asio;

    std::cout << "on_tls_init called with hdl: " << hdl.lock().get() << std::endl;
    std::cout << "using TLS mode: " << (mode == MOZILLA_MODERN ? "Mozilla Modern" : "Mozilla Intermediate") << std::endl;

    context_ptr ctx = websocketpp::lib::make_shared<asio::ssl::context>(asio::ssl::context::sslv23);

    try {
        if (mode == MOZILLA_MODERN) {
            // Modern disables TLSv1
            ctx->set_options(asio::ssl::context::default_workarounds |
                             asio::ssl::context::no_sslv2 |
                             asio::ssl::context::no_sslv3 |
                             asio::ssl::context::no_tlsv1 |
                             asio::ssl::context::single_dh_use);
        } else {
            ctx->set_options(asio::ssl::context::default_workarounds |
                             asio::ssl::context::no_sslv2 |
                             asio::ssl::context::no_sslv3 |
                             asio::ssl::context::single_dh_use);
        }
        ctx->set_password_callback(bind(&get_password));
        ctx->use_certificate_chain_file("C:\\Users\\alberto.garcia\\Documents\\code\\websocketpp\\build_86\\bin\\Debug\\server.pem");
        ctx->use_private_key_file("C:\\Users\\alberto.garcia\\Documents\\code\\websocketpp\\build_86\\bin\\Debug\\server.pem", asio::ssl::context::pem);
        
        // Example method of generating this file:
        // `openssl dhparam -out dh.pem 2048`
        // Mozilla Intermediate suggests 1024 as the minimum size to use
        // Mozilla Modern suggests 2048 as the minimum size to use.
        ctx->use_tmp_dh_file("C:\\Users\\alberto.garcia\\Documents\\code\\websocketpp\\build_86\\bin\\Debug\\dh.pem");
        
        std::string ciphers;
        
        if (mode == MOZILLA_MODERN) {
            ciphers = "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:!MD5:!PSK";
        } else {
            ciphers = "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA";
        }
        
        if (SSL_CTX_set_cipher_list(ctx->native_handle() , ciphers.c_str()) != 1) {
            std::cout << "Error setting cipher list" << std::endl;
        }
    } catch (std::exception& e) {
        std::cout << "Exception: " << e.what() << std::endl;
    }
    return ctx;
}

asio::error_code ws_proxy::connect_SSH_server(asio::ip::tcp::socket* ssh_socket){
    asio::io_service io_service;
    asio::error_code err;
    asio::ip::tcp::socket socket(io_service);
    ssh_socket->connect(asio::ip::tcp::endpoint(asio::ip::address::from_string("127.0.0.1"), 22), err);

    if (err) {
        std::cout << "Error connecting to SSH on localhost. " <<err.message() << "\n";
    }
    return err;
}

void ws_proxy::read_SSH(asio::ip::tcp::socket* ssh_socket, server* s) {
    /*asio::streambuf receive_buffer;
    asio::error_code error;
    asio::read(socket, receive_buffer, asio::transfer_all(), error);
    if (error && error != asio::error::eof) {
        std::cout << "receive failed: " << error.message() << std::endl;
    }
    else {
        const char* data = asio::buffer_cast<const char*>(receive_buffer.data());
        std::cout << data << std::endl;
    }*/


}

void ws_proxy::on_open(server* s, websocketpp::connection_hdl hdl) {
    asio::io_service io_service;
    asio::error_code err;
    auto socket = std::make_shared <asio::ip::tcp::socket>(io_service);
    socket->connect(asio::ip::tcp::endpoint(asio::ip::address::from_string("127.0.0.1"), 22), err);

    if (err) {
        std::cout << "Error connecting to SSH on localhost. " << err.message() << "\n";
    }
    else {
        void* shr_ptr_hdl = hdl.lock().get();
        active_connections[shr_ptr_hdl] = socket;
    }
}

void ws_proxy::on_close(server* s, websocketpp::connection_hdl hdl) {
   /* if (active_connections.find(hdl) != active_connections.end()) {
        active_connections.erase(hdl);
    }*/
}

int main() {
    ws_proxy ws_server;
    if (ws_server.is_SSH_server_up() == false) {
        return 1;
    }

    std::thread cthread(&ws_proxy::run, &ws_server);

    //websocketpp::lib::thread cthread(websocketpp::lib::bind(ws_server.run(), websocketpp::lib::placeholders::_1));

    cthread.detach();
}
